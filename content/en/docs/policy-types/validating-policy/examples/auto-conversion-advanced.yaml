# Advanced ValidatingPolicy with auto-conversion featuring variables and complex logic
# This example demonstrates more sophisticated auto-conversion capabilities
apiVersion: policies.kyverno.io/v1alpha1
kind: ValidatingPolicy
metadata:
  name: restrict-image-registries
  namespace: security-policies
  annotations:
    policies.kyverno.io/title: "Restrict Container Image Registries"
    policies.kyverno.io/category: "Security"
    policies.kyverno.io/description: >-
      Ensures all container images come from approved registries to prevent
      supply chain attacks and maintain security compliance.
spec:
  # Enable auto-conversion to ValidatingAdmissionPolicy
  autogen:
    validatingAdmissionPolicy:
      enabled: true
  
  # Policy enforcement and evaluation settings
  validationActions: [Deny]
  evaluation:
    background:
      enabled: true  # This will still work via ValidatingPolicy for background scanning
  
  # Apply to Pod resources
  matchConstraints:
    resourceRules:
    - apiGroups: [""]
      apiVersions: ["v1"]
      operations: ["CREATE", "UPDATE"] 
      resources: ["pods"]
  
  # Variables for reusable values
  variables:
  - name: allowedRegistry
    expression: '"registry.company.com"'
  - name: allowedTestRegistry  
    expression: '"test-registry.company.com"'
  
  # Complex validation with multiple conditions
  validations:
  - name: check-image-registry
    expression: |
      object.spec.containers.all(container, 
        container.image.startsWith(variables.allowedRegistry) || 
        container.image.startsWith(variables.allowedTestRegistry))
    messageExpression: |
      '"Container images must be from approved registries. " +
      "Allowed: " + variables.allowedRegistry + ", " + variables.allowedTestRegistry + ". " +
      "Found images: " + object.spec.containers.map(c, c.image).join(", ")'
  
  - name: check-init-containers
    expression: |
      !has(object.spec.initContainers) ||
      object.spec.initContainers.all(container,
        container.image.startsWith(variables.allowedRegistry) ||
        container.image.startsWith(variables.allowedTestRegistry))
    message: "Init container images must also be from approved registries"

---
# ConfigMap referenced by the policy (optional - for more dynamic configurations)
apiVersion: v1
kind: ConfigMap
metadata:
  name: registry-config
  namespace: security-policies
data:
  allowed-registries: |
    registry.company.com
    test-registry.company.com
  blocked-registries: |
    docker.io
    quay.io

---
# Example of a more complex ValidatingPolicy with conditional logic
apiVersion: policies.kyverno.io/v1alpha1
kind: ValidatingPolicy
metadata:
  name: enforce-resource-constraints
  namespace: default
spec:
  autogen:
    validatingAdmissionPolicy:
      enabled: true
  
  validationActions: [Deny]
  
  matchConstraints:
    resourceRules:
    - apiGroups: [""]
      apiVersions: ["v1"]
      operations: ["CREATE", "UPDATE"]
      resources: ["pods"]
    - apiGroups: ["apps"]
      apiVersions: ["v1"]
      operations: ["CREATE", "UPDATE"]
      resources: ["deployments", "statefulsets", "daemonsets"]
  
  variables:
  - name: maxCpuLimit
    expression: '"2"'
  - name: maxMemoryLimit
    expression: '"4Gi"'
  
  validations:
  - name: resource-limits-required
    expression: |
      (object.kind == "Pod" && 
       object.spec.containers.all(container,
         has(container.resources.limits.cpu) && 
         has(container.resources.limits.memory))) ||
      (object.kind != "Pod" &&
       object.spec.template.spec.containers.all(container,
         has(container.resources.limits.cpu) && 
         has(container.resources.limits.memory)))
    message: "All containers must have CPU and memory limits defined"
  
  - name: cpu-limit-constraint
    expression: |
      (object.kind == "Pod" && 
       object.spec.containers.all(container,
         has(container.resources.limits.cpu) &&
         quantity(container.resources.limits.cpu) <= quantity(variables.maxCpuLimit))) ||
      (object.kind != "Pod" &&
       object.spec.template.spec.containers.all(container,
         has(container.resources.limits.cpu) &&
         quantity(container.resources.limits.cpu) <= quantity(variables.maxCpuLimit)))
    messageExpression: |
      '"CPU limit cannot exceed " + variables.maxCpuLimit + 
      " cores per container for resource efficiency"'
  
  - name: memory-limit-constraint
    expression: |
      (object.kind == "Pod" && 
       object.spec.containers.all(container,
         has(container.resources.limits.memory) &&
         quantity(container.resources.limits.memory) <= quantity(variables.maxMemoryLimit))) ||
      (object.kind != "Pod" &&
       object.spec.template.spec.containers.all(container,
         has(container.resources.limits.memory) &&
         quantity(container.resources.limits.memory) <= quantity(variables.maxMemoryLimit)))
    messageExpression: |
      '"Memory limit cannot exceed " + variables.maxMemoryLimit + 
      " per container to prevent resource exhaustion"'

# Performance Note:
# These advanced examples will generate ValidatingAdmissionPolicies that run
# natively in the Kubernetes API server, providing:
# - 25% average latency improvement over webhook-based policies
# - Up to 80% CPU reduction in high-throughput scenarios
# - 59% less memory usage in multi-replica deployments
# - Enhanced reliability through in-process validation